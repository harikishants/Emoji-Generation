import torch
import torch.nn as nn
import matplotlib.pyplot as plt

class Generator(nn.Module):

    def __init__(self,):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(2, 64),
            nn.LeakyReLU(0.01),
            nn.Linear(64, 64),
            nn.LeakyReLU(0.01),
            nn.Linear(64, 2)
        )

    def forward(self, x):
        return self.net(x)
    
class Discriminator(nn.Module):

    def __init__(self,):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(2, 64),
            nn.LeakyReLU(0.01),
            nn.Linear(64, 64),
            nn.LeakyReLU(0.01),
            nn.Linear(64, 1),
            nn.Sigmoid()
        )

    def forward(self, x):
        return self.net(x)

def quadratic(x):
    return x**2

def generate_real_points(num_points=100, dim=2, low=-10, high=10):

    x = torch.rand(100) * (high - low) + low 
    y = quadratic(x)
    X_real = torch.stack((x,y), dim=1)
    y_labels = torch.ones(num_points, 1)

    return X_real, y_labels

def generate_fake_points(generator, num_points=100):

    noise = torch.rand(num_points,2)
    X_fake = generator(noise)
    y_labels = torch.zeros(num_points, 1) # points generated by generator is fake for the discriminator (for training)

    return X_fake, y_labels


def train_discriminator(discriminator, X, y):
    pass

def train_generator(generator, discriminator, X, y):
    pass

def plot(generator, num_points=100):
    noise = torch.rand(num_points, 2)
    X_pred = generator(noise).detach().numpy()
    X_real, _ = generate_real_points(num_points)
    X_real = X_real.detach().numpy()

    plt.figure(figsize=(6, 6))
    plt.scatter(X_real[:, 0], X_real[:, 1], c='green', label='Real Data', alpha=0.6)
    plt.scatter(X_pred[:, 0], X_pred[:, 1], c='red', label='Generated Data (Fake)', alpha=0.6)
    plt.title("Real vs Generated Points")
    plt.xlabel("x")
    plt.ylabel("y")
    plt.legend()
    plt.grid(True)
    plt.savefig('quadratic.png')
    # plt.show()


if __name__ == "__main__":

    generator = Generator()
    discriminator = Discriminator()

    num_points=100

    criterion = nn.BCELoss()
    d_optimizer = torch.optim.AdamW(discriminator.parameters(), lr=1e-3)
    g_optimizer = torch.optim.AdamW(generator.parameters(), lr=1e-3)

    epochs = 10000

    for i in range(epochs):

        if (i+1)%500 == 0:
            print(f'[info] Epoch {i+1}')
            plot(generator, num_points)

        X_real, y_real = generate_real_points(num_points)
        X_fake, y_fake = generate_fake_points(generator, num_points)

        X = torch.cat((X_real, X_fake), dim=0)
        y = torch.cat((y_real, y_fake), dim=0)

        indices = torch.randperm(X.size(0)) # for shuffling
        X = X[indices]
        y = y[indices]

        discriminator.train()
        d_optimizer.zero_grad()
        d_pred = discriminator(X)
        d_loss = criterion(d_pred, y)
        d_loss.backward()
        d_optimizer.step()

        generator.train()
        g_optimizer.zero_grad()
        noise = torch.rand(num_points,2)
        g_pred = discriminator(generator(noise))
        g_loss = criterion(g_pred, torch.ones(num_points,1))
        g_loss.backward()
        g_optimizer.step()

